#!/usr/bin/env python
import os
import subprocess
import base64
import webbrowser
from pathlib import Path
import uvicorn
from fastapi import FastAPI
from fastapi.responses import HTMLResponse
import argparse
import tempfile
import shutil

app = FastAPI()

# Paths
CARGO_TOML = Path("Cargo.toml")
WASM_TARGET = "wasm32-unknown-unknown"
RELEASE_DIR = Path(f"target/{WASM_TARGET}/release")
TEMP_DIR = Path(tempfile.mkdtemp())

def get_crate_name():
    """Extract crate name from Cargo.toml."""
    with open(CARGO_TOML, "r") as f:
        for line in f:
            if line.strip().startswith("name"):
                parts = line.split("=")
                if len(parts) == 2:
                    return parts[1].strip().strip('"').strip("'")
    raise ValueError("Could not find crate name in Cargo.toml")

def build_wasm():
    """Build the WebAssembly binary."""
    print("Building WASM target...")
    result = subprocess.run(
        ["cargo", "build", "--lib", "--target", WASM_TARGET, "--release"],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        print("Failed to build WASM target:")
        print(result.stderr)
        return False
    
    # Check if wasm-bindgen-cli is installed
    try:
        subprocess.run(["wasm-bindgen", "--version"], capture_output=True, check=True)
    except (subprocess.SubprocessError, FileNotFoundError):
        print("Installing wasm-bindgen-cli...")
        subprocess.run(["cargo", "install", "wasm-bindgen-cli"], check=True)
    
    # Run wasm-bindgen to create JavaScript bindings
    crate_name = get_crate_name()
    wasm_path = RELEASE_DIR / f"{crate_name}.wasm"
    
    print("Generating wasm-bindgen bindings...")
    result = subprocess.run([
        "wasm-bindgen",
        str(wasm_path),
        "--out-dir", str(TEMP_DIR),
        "--target", "web"
    ], capture_output=True, text=True)
    
    if result.returncode != 0:
        print("Failed to generate wasm-bindgen bindings:")
        print(result.stderr)
        return False
    
    print("WASM build and binding generation successful!")
    return True

def create_html_template(crate_name):
    """Create HTML template with JavaScript to load WASM."""
    # The JS and WASM filenames generated by wasm-bindgen
    js_filename = f"{crate_name}.js"
    wasm_filename = f"{crate_name}_bg.wasm"
    
    return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>XOS WASM Viewport</title>
    <style>
        body {{ margin: 0; padding: 0; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; }}
        canvas {{ display: block; }}
    </style>
</head>
<body>
    <canvas id="canvas" width="320" height="240"></canvas>

    <script type="module">
        import init from '/js/{js_filename}';

        async function run() {{
            // Initialize the WASM module
            await init('/wasm/{wasm_filename}');
            
            // Set up canvas
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            // Custom implementation of update_display that wasm can call
            window.update_display = (ptr, width, height) => {{
                // This function will be implemented by your Rust wasm module
                // to update the display
            }};
            
            // Additional setup can go here
        }}

        run();
    </script>
</body>
</html>"""

# Define routes to serve the WASM app and files
@app.get("/", response_class=HTMLResponse)
async def serve_wasm_app():
    crate_name = get_crate_name()
    
    # Check if WASM file exists, build if necessary
    if not (TEMP_DIR / f"{crate_name}_bg.wasm").exists():
        if not build_wasm():
            return HTMLResponse(content="<h1>Error building WASM</h1>", status_code=500)
    
    # Create HTML
    html_content = create_html_template(crate_name)
    
    return HTMLResponse(content=html_content)

@app.get("/js/{file_path:path}")
async def serve_js(file_path: str):
    from fastapi.responses import FileResponse
    file_path = TEMP_DIR / file_path
    if file_path.exists() and file_path.is_file():
        return FileResponse(file_path, media_type="application/javascript")
    return {"error": "File not found"}, 404

@app.get("/wasm/{file_path:path}")
async def serve_wasm_file(file_path: str):
    from fastapi.responses import FileResponse
    file_path = TEMP_DIR / file_path
    if file_path.exists() and file_path.is_file():
        return FileResponse(file_path, media_type="application/wasm")
    return {"error": "File not found"}, 404

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Serve Rust WASM application")
    parser.add_argument("--host", default="127.0.0.1", help="Host to bind server to")
    parser.add_argument("--port", type=int, default=8000, help="Port to bind server to")
    parser.add_argument("--no-open", action="store_true", help="Don't open browser automatically")
    args = parser.parse_args()
    
    # Ensure WASM target is installed
    subprocess.run(["rustup", "target", "add", WASM_TARGET], 
                   capture_output=True, check=False)
    
    # Build WASM before starting server
    build_wasm()
    
    # Open browser
    if not args.no_open:
        webbrowser.open(f"http://{args.host}:{args.port}")
    
    # Start server
    print(f"Starting server at http://{args.host}:{args.port}")
    try:
        uvicorn.run(app, host=args.host, port=args.port)
    finally:
        # Clean up temporary directory
        shutil.rmtree(TEMP_DIR, ignore_errors=True)